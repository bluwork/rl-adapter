<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="cf73862d-9617-40e0-a99c-a127708a2e16" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/src/rl_adapter/exp_replay.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/rl_adapter/dqn.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/rl_adapter/dqn.clj" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Test Namespace" />
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="MacroExpansionManager">
    <option name="directoryName" value="GcjmizaN" />
  </component>
  <component name="ProjectId" id="1Pk4FdMO6TNUoMMGOUg1oR7Cu8K" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="PropertiesComponent">
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="cursive.last.file.extension./Users/blu/Desktop/ZavrsniRad/Kod/Clojure/rl-adapter/src" value="clj" />
    <property name="cursive.last.file.extension./Users/blu/Desktop/ZavrsniRad/Kod/Clojure/rl-adapter/test" value="clj" />
    <property name="cursive.last.file.extension./Users/bobanlukic/Desktop/ZavrsniRad/Kod/Clojure/rl-adapter/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="preferences.keymap" />
  </component>
  <component name="ReplState" timestamp="1567243840568">{:repl-history {:ide [], :local [{:command &quot;(.addLast buffer 0)&quot;, :offset 19, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(.size buffer)&quot;, :offset 14, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn initial-capacity\n  []\n  (/ (count @replay-memory) (:initial-size conf)))&quot;, :offset 78, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn capacity []\n  (/ (count @replay-memory) (:max-capacity conf)))&quot;, :offset 68, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append \n  [transition]\n  (swap! replay-memory conj transition))&quot;, :offset 69, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s0 (byte-array (range 10) :a 0 :r 34 :done false :s1 (byte-array (range 12 18)))})&quot;, :offset 92, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s0 (byte-array (range 10) :a 0 :r 34 :done false :s1 (byte-array (range 10)))})&quot;, :offset 89, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s0 (byte-array (range 10)) :a 0 :r 34 :done false :s1 (byte-array (range 12 18))})&quot;, :offset 92, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s0 (byte-array (range 8)) :a 2 :r 44 :done false :s1 (byte-array (range 12 11))})&quot;, :offset 91, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(capacity)&quot;, :offset 10, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(initial-capacity)&quot;, :offset 18, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size]))&quot;, :offset 61, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state, :a action, :r reward, :d done, :s-1 next-state}\n   to replay memory\&quot;\n  [transition]\n  (swap! replay-memory conj transition))&quot;, :offset 189, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(in-cap)&quot;, :offset 8, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(&lt; 1 (cap))&quot;, :offset 11, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(&lt; (cap) 1)&quot;, :offset 11, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s-0 1 :a 1 :r 22 :d false :s-1 2})&quot;, :offset 44, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(count @replay-memory)&quot;, :offset 22, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(rand-int (count @replay-memory))&quot;, :offset 33, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(nth (rand-int (count @replay-memory)) @replay-memory)&quot;, :offset 54, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(nth  @replay-memory (rand-int (count @replay-memory)))&quot;, :offset 55, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size]\n   (take batch-size (nth  @replay-memory (rand-int (count @replay-memory))))))&quot;, :offset 138, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size]\n   ((nth  @replay-memory (rand-int (count @replay-memory))))))&quot;, :offset 122, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size]\n   (nth  @replay-memory (rand-int (count @replay-memory)))))&quot;, :offset 120, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn random-element\n  \&quot;\&quot;\n  []\n  (nth  @replay-memory (rand-int (count @replay-memory))))&quot;, :offset 89, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size] \n   (loop [batch [] size batch-size] \n     (if (&lt; size 1)\n       batch\n       (recur (conj batch (random-element) (dec size)))))))&quot;, :offset 190, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size] \n   (loop [batch [] size batch-size] \n     (if (&lt; size 1)\n       batch\n       (recur (conj batch (random-element)) (dec size))))))&quot;, :offset 190, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action, :r reward, :d done, :s-1 next-state}\n   to replay memory\&quot;\n  [transition]\n  (swap! replay-memory conj transition))&quot;, :offset 188, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 1 :a 2})&quot;, :offset 21, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(some #(= % %) @replay-memory)&quot;, :offset 30, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(some #({:s1 1 :a 4}) @replay-memory)&quot;, :offset 37, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;replay-memory&quot;, :offset 13, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(some #(= % {:s1 1 :a 4}) @replay-memory)&quot;, :offset 41, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(some #(= % {:s1 1 :a 3}) @replay-memory)&quot;, :offset 41, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(some #(= % {:s1 0 :a 2}) @replay-memory)&quot;, :offset 41, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(some #(= % {:s1 1 :a 2}) @replay-memory)&quot;, :offset 41, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action, :r reward, :d done, :s-1 next-state}\n   to replay memory\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (swap! replay-memory conj transition)))&quot;, :offset 246, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 1 :a 3})&quot;, :offset 21, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 1 :a 4})&quot;, :offset 21, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 1 :a 5})&quot;, :offset 21, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 1 :a 6})&quot;, :offset 21, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(while (&lt; i 20)\n  (println (dec i)))&quot;, :offset 36, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [i 20] \n  (while (&gt; i 1)\n    (println (dec i))))&quot;, :offset 53, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [i (atom 20)]\n  (while (&gt; @i 1)\n    (println (swap! i dec))))&quot;, :offset 66, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(def replay-memory (atom []))&quot;, :offset 29, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn random-element\n  \&quot;\&quot;\n  []\n  (rand-nth  @replay-memory))&quot;, :offset 60, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  ([] (sample-batch 32))\n  ([batch-size]\n   (loop [batch [] size batch-size]\n     (if (&lt; size 1)\n       batch\n       (recur (conj batch (random-element)) (dec size))))))&quot;, :offset 188, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (swap! replay-memory conj transition)))&quot;, :offset 278, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [i (atom 100)]\n  (while (&gt; @i 1)\n    (append {:s1 i :a (* i 3)}) \n    (swap! i dec)))&quot;, :offset 90, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [i (atom 100)]\n  (while (&gt; @i 1)\n    (append {:s1 @i :a (* @i 3)}) \n    (swap! i dec)))&quot;, :offset 92, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [i (atom 100)]\n  (while (&gt; @i 0)\n    (append {:s1 @i :a (* @i 3)}) \n    (swap! i dec)))&quot;, :offset 92, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(sample-batch)&quot;, :offset 14, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when  (&lt; cap 1)\n      (swap! replay-memory remove 0))\n    (swap! replay-memory conj transition)))&quot;, :offset 337, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(doc append)&quot;, :offset 12, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(use '[clojure.repl :as repl])&quot;, :offset 30, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(repl/doc append)&quot;, :offset 17, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [counter (atom 55000)]\n  (while (&gt; @counter 0)\n    (append {:s-1 @counter :a 1 :b 23 :c 34})))&quot;, :offset 99, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when  (&lt; cap 1)\n      (swap! replay-memory remove 0))\n    (swap! replay-memory conj transition)))&quot;, :offset 393, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1})&quot;, :offset 14, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(def\n  \&quot;Replay memory buffer, hold previous transitions\&quot;\n  replay-memory (atom []))&quot;, :offset 83, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when  (&lt; cap 1)(swap! replay-memory pop))\n    (swap! replay-memory conj transition)))&quot;, :offset 381, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    ;(when  (&lt; cap 1)(swap! replay-memory pop))\n    (swap! replay-memory conj transition)))&quot;, :offset 382, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when  (&lt; cap 1)(reset! replay-memory rest))\n    (swap! replay-memory conj transition)))&quot;, :offset 383, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 3})&quot;, :offset 16, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    ;(when  (&lt; cap 1)(reset! replay-memory rest))\n    (swap! replay-memory conj transition)))&quot;, :offset 384, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(append {:s1 4})&quot;, :offset 16, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [veca (atom [1 2 3 4])]\n  (swap! veca rest))&quot;, :offset 49, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [veca (atom [1 2 3 4])]\n  (reset! veca rest))&quot;, :offset 50, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when  (&lt; cap 1)(swap! replay-memory rest))\n    (swap! replay-memory conj transition)))&quot;, :offset 382, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    ;(when  (&lt; cap 1)(swap! replay-memory rest))\n    (swap! replay-memory conj transition)))&quot;, :offset 383, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [counter (atom 55000)]\n  (while (&gt; @counter 0)\n    (append {:s-1 @counter :a 1 :b 23 :c 34})\n    (swap! counter dec)))&quot;, :offset 123, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [counter (atom 55000)]\n  (while (&gt; @counter 0)\n    ;(append {:s-1 @counter :a 1 :b 23 :c 34})\n    (println @counter)\n    (swap! counter dec)))&quot;, :offset 147, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(ns rl-adapter.exp-replay)&quot;, :offset 26, :ns &quot;rl-adapter.core&quot;} {:command &quot;(def conf {:initial-size 10000\n           :max-capacity 50000})&quot;, :offset 63, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn random-element\n  \&quot;Return random element from memory.\n  Note: Can return duplicates.\&quot;\n  []\n  (rand-nth  @replay-memory))&quot;, :offset 125, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn sample-batch\n  \&quot;Return array of transition maps, size of array is batch-size.\&quot;\n  ([] (sample-batch 32))\n  ([batch-size]\n   (loop [batch [] size batch-size]\n     (if (&lt; size 1)\n       batch\n       (recur (conj batch (random-element)) (dec size))))))&quot;, :offset 254, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn in-cap\n  \&quot;Return ratio between current memory size and initial capacity size.\&quot;\n  []\n  (/ (count @replay-memory) (:initial-size conf)))&quot;, :offset 140, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [cnt (atom 200)]\n  (while (&gt; @cnt 0)\n    (do \n      (println @cnt)\n      (swap! cnt dec))))&quot;, :offset 96, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [nums (atom (range 10))]\n  (swap! nums rest))&quot;, :offset 50, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(swap! replay-memory rest)&quot;, :offset 26, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn cap\n  \&quot;Return ratio between current  and maximal memory size.\&quot;\n  []\n  (/ (count @replay-memory) (:max-capacity conf)))&quot;, :offset 124, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [cnt (atom 200)]\n  (while (&gt; @cnt 0)\n    (do\n      (append {:s-1 @count})\n      (swap! cnt dec))))&quot;, :offset 103, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(if (&lt; cap 1))&quot;, :offset 14, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(if (&lt; cap 1) true)&quot;, :offset 19, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn in-cap\n  \&quot;Return ratio between current memory size and initial capacity size.\&quot;\n  []\n  (double (/ (count @replay-memory) (:initial-size conf))))&quot;, :offset 149, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when  (&lt; cap 1)(swap! replay-memory subvec 1))\n    (swap! replay-memory conj transition)))&quot;, :offset 386, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn cap\n  \&quot;Return ratio between current  and maximal memory size.\&quot;\n  []\n  (double (/ (count @replay-memory) (:max-capacity conf))))&quot;, :offset 133, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(def cap\n  \&quot;Return ratio between current  and maximal memory size.\&quot;\n\n  (double (/ (count @replay-memory) (:max-capacity conf))))&quot;, :offset 128, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(double (/ (count @replay-memory) (:max-capacity conf)))&quot;, :offset 56, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn cap\n  \&quot;Return ratio between current  and maximal memory size.\&quot;[]\n  (double (/ (count @replay-memory) (:max-capacity conf))))&quot;, :offset 130, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;cap&quot;, :offset 3, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(cap)&quot;, :offset 5, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(if (&lt; cap 1.0) true)&quot;, :offset 21, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(if (&lt; (cap) 1.0) true)&quot;, :offset 23, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when (&lt; (cap) 1) (swap! replay-memory subvec 1))\n    (swap! replay-memory conj transition)))&quot;, :offset 388, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(def\n  replay-memory (atom []))&quot;, :offset 31, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(defn append\n  \&quot;Append map with transition data:\n   {:s-0 state :a action :r reward :d done :s-1 next-state}\n   to replay memory. Same transition data is rejected.\n   If max capacity is reached first element is removed.\&quot;\n  [transition]\n  (when (nil? (some #(= % transition) @replay-memory))\n    (when (&gt; (cap) 1) (swap! replay-memory subvec 1))\n    (swap! replay-memory conj transition)))&quot;, :offset 388, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [cnt (atom 200)]\n  (while (&gt; @cnt 0)\n    (do\n      (append {:s-1 @cnt})\n      (swap! cnt dec))))&quot;, :offset 101, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;@replay-memory&quot;, :offset 14, :ns &quot;rl-adapter.exp-replay&quot;} {:command &quot;(let [cnt (atom 55000)]\n  (while (&gt; @cnt 0)\n    (do\n      (append {:s-1 @cnt})\n      (swap! cnt dec))))&quot;, :offset 103, :ns &quot;rl-adapter.exp-replay&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager">
    <configuration name="REPL for rl-adapter" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" temporary="true">
      <module name="rl-adapter" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure REPL.REPL for rl-adapter" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="cf73862d-9617-40e0-a99c-a127708a2e16" name="Default Changelist" comment="" />
      <created>1566404657787</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1566404657787</updated>
    </task>
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>